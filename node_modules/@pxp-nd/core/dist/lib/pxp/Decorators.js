"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoredProcedure = exports.Model = exports.ReadOnly = exports.DbSettings = exports.Permission = exports.Log = exports.Authentication = exports.Route = exports.Patch = exports.Delete = exports.Put = exports.Post = exports.Get = void 0;
const Get = (path = '') => {
    return (target, propertyKey) => {
        if (!Reflect.hasMetadata('routes', target.constructor)) {
            Reflect.defineMetadata('routes', [], target.constructor);
        }
        // Get the routes stored so far, extend it by the new route and re-set the metadata.
        const routes = Reflect.getMetadata('routes', target.constructor);
        routes.push({
            requestMethod: 'get',
            path: path === '' ? '/' + propertyKey : path,
            methodName: propertyKey
        });
        Reflect.defineMetadata('routes', routes, target.constructor);
    };
};
exports.Get = Get;
const Post = (path = '') => {
    return (target, propertyKey) => {
        // In case this is the first route to be registered the `routes` metadata is likely to be undefined at this point.
        // To prevent any further validation simply set it to an empty array here.
        if (!Reflect.hasMetadata('routes', target.constructor)) {
            Reflect.defineMetadata('routes', [], target.constructor);
        }
        // Get the routes stored so far, extend it by the new route and re-set the metadata.
        const routes = Reflect.getMetadata('routes', target.constructor);
        routes.push({
            requestMethod: 'post',
            path: path === '' ? '/' + propertyKey : path,
            methodName: propertyKey
        });
        Reflect.defineMetadata('routes', routes, target.constructor);
    };
};
exports.Post = Post;
const Put = (path = '') => {
    return (target, propertyKey) => {
        // In case this is the first route to be registered the `routes` metadata is likely to be undefined at this point.
        // To prevent any further validation simply set it to an empty array here.
        if (!Reflect.hasMetadata('routes', target.constructor)) {
            Reflect.defineMetadata('routes', [], target.constructor);
        }
        // Get the routes stored so far, extend it by the new route and re-set the metadata.
        const routes = Reflect.getMetadata('routes', target.constructor);
        routes.push({
            requestMethod: 'put',
            path: path === '' ? '/' + propertyKey : path,
            methodName: propertyKey
        });
        Reflect.defineMetadata('routes', routes, target.constructor);
    };
};
exports.Put = Put;
const Delete = (path = '') => {
    return (target, propertyKey) => {
        // In case this is the first route to be registered the `routes` metadata is likely to be undefined at this point.
        // To prevent any further validation simply set it to an empty array here.
        if (!Reflect.hasMetadata('routes', target.constructor)) {
            Reflect.defineMetadata('routes', [], target.constructor);
        }
        // Get the routes stored so far, extend it by the new route and re-set the metadata.
        const routes = Reflect.getMetadata('routes', target.constructor);
        routes.push({
            requestMethod: 'delete',
            path: path === '' ? '/' + propertyKey : path,
            methodName: propertyKey
        });
        Reflect.defineMetadata('routes', routes, target.constructor);
    };
};
exports.Delete = Delete;
const Patch = (path = '') => {
    return (target, propertyKey) => {
        // In case this is the first route to be registered the `routes` metadata is likely to be undefined at this point.
        // To prevent any further validation simply set it to an empty array here.
        if (!Reflect.hasMetadata('routes', target.constructor)) {
            Reflect.defineMetadata('routes', [], target.constructor);
        }
        // Get the routes stored so far, extend it by the new route and re-set the metadata.
        const routes = Reflect.getMetadata('routes', target.constructor);
        routes.push({
            requestMethod: 'patch',
            path: path === '' ? '/' + propertyKey : path,
            methodName: propertyKey
        });
        Reflect.defineMetadata('routes', routes, target.constructor);
    };
};
exports.Patch = Patch;
const Route = (controllerPath = '') => {
    return (target) => {
        Reflect.defineMetadata('controller_path', controllerPath, target);
        // Since routes are set by our methods this should almost never be true (except the controller has no methods)
        if (!Reflect.hasMetadata('routes', target)) {
            Reflect.defineMetadata('routes', [], target);
        }
    };
};
exports.Route = Route;
const Model = (model) => {
    return (target) => {
        Reflect.defineMetadata('model', model, target);
    };
};
exports.Model = Model;
const StoredProcedure = (storedProcedure) => {
    return (target) => {
        Reflect.defineMetadata('storedprocedure', storedProcedure, target);
    };
};
exports.StoredProcedure = StoredProcedure;
const Authentication = (authentication = true) => {
    return (target, propertyKey) => {
        if (!Reflect.hasMetadata('authentication', target.constructor)) {
            Reflect.defineMetadata('authentication', {}, target.constructor);
        }
        const aut = Reflect.getMetadata('authentication', target.constructor);
        aut[propertyKey] = authentication;
        Reflect.defineMetadata('authentication', aut, target.constructor);
    };
};
exports.Authentication = Authentication;
const Log = (log = true, config = {}) => {
    return (target, propertyKey) => {
        if (!Reflect.hasMetadata('log', target.constructor)) {
            Reflect.defineMetadata('log', [], target.constructor);
        }
        if (!Reflect.hasMetadata('logConfig', target.constructor)) {
            Reflect.defineMetadata('logConfig', [], target.constructor);
        }
        const logVar = Reflect.getMetadata('log', target.constructor);
        logVar[propertyKey] = log;
        const logConfig = Reflect.getMetadata('logConfig', target.constructor);
        logConfig[propertyKey] = config;
        Reflect.defineMetadata('log', logVar, target.constructor);
        Reflect.defineMetadata('logConfig', logConfig, target.constructor);
    };
};
exports.Log = Log;
const Permission = (permission = true) => {
    return (target, propertyKey) => {
        if (!Reflect.hasMetadata('permission', target.constructor)) {
            Reflect.defineMetadata('permission', [], target.constructor);
        }
        const perVar = Reflect.getMetadata('permission', target.constructor);
        perVar[propertyKey] = permission;
        Reflect.defineMetadata('permission', perVar, target.constructor);
    };
};
exports.Permission = Permission;
const ReadOnly = (ronly = true) => {
    return (target, propertyKey) => {
        if (!Reflect.hasMetadata('readonly', target.constructor)) {
            Reflect.defineMetadata('readonly', [], target.constructor);
        }
        const rOnlyVar = Reflect.getMetadata('readonly', target.constructor);
        rOnlyVar[propertyKey] = ronly;
        Reflect.defineMetadata('readonly', rOnlyVar, target.constructor);
    };
};
exports.ReadOnly = ReadOnly;
const DbSettings = (modelType) => {
    return (target, propertyKey) => {
        if (!Reflect.hasMetadata('dbsettings', target.constructor)) {
            Reflect.defineMetadata('dbsettings', [], target.constructor);
        }
        const dbvar = Reflect.getMetadata('dbsettings', target.constructor);
        dbvar[propertyKey] = modelType;
        Reflect.defineMetadata('dbsettings', dbvar, target.constructor);
    };
};
exports.DbSettings = DbSettings;
