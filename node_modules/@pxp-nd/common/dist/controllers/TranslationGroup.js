"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Kplian Ltda 2020
 *
 * MIT
 *
 * User Controller
 *
 * @summary User Controller
 * @author Israel Cm
 *
 * Created at     : 2020-09-17 18:55:38
 * Last modified  : 2020-09-17 19:04:30
 */
const typeorm_1 = require("typeorm");
const core_1 = require("@pxp-nd/core");
const entities_1 = require("../entities");
const entities_2 = require("../entities");
const entities_3 = require("../entities");
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const adm_zip_1 = __importDefault(require("adm-zip"));
const _ = __importStar(require("lodash"));
const xlsx_1 = __importDefault(require("xlsx"));
let TranslationGroup = class TranslationGroup extends core_1.Controller {
    async save(params, manager) {
        const getPathEntity = (entity) => {
            const dir = path_1.default.join(__dirname, '../../../', 'modules');
            console.log(dir);
            const modules = fs_1.default.readdirSync(dir);
            let response = { error: true };
            modules.forEach(file => {
                const files = fs_1.default.readdirSync(path_1.default.join(dir, file, 'entity'));
                const exist = _.indexOf(files, entity + '.js') >= 0;
                if (exist) {
                    response = {
                        path: path_1.default.join(dir, file, 'entity'),
                        module: file,
                    };
                }
            });
            return response;
        };
        const group = await manager.save(entities_1.TranslationGroup, Object.assign({}, params));
        if (group.type === 'table') {
            const pathEntity = getPathEntity(group.tableName);
            let model = null;
            if (!pathEntity.error) {
                model = await Promise.resolve().then(() => __importStar(require(path_1.default.join(pathEntity.path, group.tableName + '.js'))));
                const data = await manager.find(model.default);
                const words = _.map(data, (item) => {
                    return {
                        translationGroupId: group.translationGroupId,
                        code: _.camelCase(group.tableName) + '_' + group.columnTranslate + '_' + item[_.camelCase(group.tableName) + 'Id'],
                        defaultText: item[group.columnTranslate],
                    };
                });
                await manager.save(entities_2.WordKey, words);
            }
        }
        return group;
    }
    async listModules(params, manager) {
        const dir = path_1.default.join(__dirname, '../../../', 'modules');
        const modules = fs_1.default.readdirSync(dir);
        return {
            data: _.map(modules, (item) => ({ name: item }))
        };
    }
    async listTablesDb(params, manager) {
        const connection = typeorm_1.getConnection();
        const dir = path_1.default.join(__dirname, '../../../', 'modules', params.module, 'entity');
        let entities = fs_1.default.readdirSync(dir);
        entities = entities.filter(item => !item.includes('.map'));
        entities = entities.map(item => item.replace('.js', ''));
        const allEntities = _.map(connection.entityMetadatas, (item) => ({ name: item.name }));
        return {
            data: allEntities.filter(item => _.includes(entities, item.name)),
        };
    }
    async listEntityColumns(params) {
        const connection = typeorm_1.getConnection();
        const entity = _.find(connection.entityMetadatas, { name: params.entity }) || {};
        let fields = _.map(entity.columns, (item) => ({ name: item.propertyName }));
        fields = fields.filter(item => !_.includes(['createdBy', 'userIdAi', 'userAi', 'modifiedBy', 'createdAt', 'modifiedAt', 'isActive'], item.name));
        return {
            data: fields
        };
    }
    async getJsonLanguage(params, manager, res) {
        const langs = await manager.find(entities_3.Language);
        const groupInterfaces = await manager.find(entities_1.TranslationGroup, {
            where: {
                type: 'interface',
            },
            relations: ['words']
        });
        const createByLang = (languageId) => {
            const data = {};
            groupInterfaces.forEach(group => {
                const items = {};
                group.words.forEach(item => {
                    const translate = _.find(item.translates, { languageId });
                    items[item.code] = translate ? translate.text : item.defaultText;
                });
                data[group.code] = Object.assign({}, items);
            });
            return data;
        };
        const jsonFiles = {};
        langs.forEach((lang) => jsonFiles[lang.code] = createByLang(lang.languageId));
        //create folders
        const temp = path_1.default.join(__dirname, '/../../../tmp/locales');
        if (!fs_1.default.existsSync(temp)) {
            fs_1.default.mkdirSync(temp, { recursive: true });
            langs.forEach((item) => fs_1.default.mkdirSync(temp + '/' + item.code));
        }
        const files = [];
        Object.keys(jsonFiles).forEach(key => {
            Object.keys(jsonFiles[key]).forEach(elem => {
                files.push(fs_1.default.promises.writeFile(path_1.default.join(temp, key, elem + '.json'), JSON.stringify(jsonFiles[key][elem]), 'utf8'));
            });
        });
        await Promise.all(files);
        const zip = new adm_zip_1.default();
        // Object.keys(jsonFiles).forEach(key=>zip.addLocalFile(key +'.json'));
        zip.addLocalFolder(path_1.default.join(temp, '../'));
        const name = 'locales.zip';
        const data = zip.toBuffer();
        res.set('Content-Type', 'application/octet-stream');
        res.set('Content-Disposition', `attachment; filename=${name}`);
        res.set('Content-Length', data.length);
        res.send(data);
        // return jsonFiles;
    }
    async getCsvLanguage(params, manager, res) {
        const langs = await manager.find(entities_3.Language, { order: { code: 'ASC' } });
        const groupInterfaces = await manager.find(entities_1.TranslationGroup, {
            // where: {
            //   type: 'interface',
            // },
            relations: ['words'],
            order: { type: 'ASC' },
        });
        // Data
        const header = ['code', 'defaultText', ...langs.map((item) => item.code)];
        const wb = xlsx_1.default.utils.book_new();
        groupInterfaces.forEach(group => {
            const items = [header];
            group.words.forEach(item => {
                const translates = _.orderBy(item.translates, ['code'], ['asc']);
                items.push([
                    item.code,
                    item.defaultText,
                    ...translates.map((t) => t.text),
                ]);
            });
            const ws = xlsx_1.default.utils.aoa_to_sheet(items);
            xlsx_1.default.utils.book_append_sheet(wb, ws, group.code);
        });
        const name = 'locales.xlsx';
        // write options
        const wopts = { bookType: 'xlsx', bookSST: false, type: 'base64' };
        const buffer = xlsx_1.default.write(wb, wopts);
        res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
        res.set('Content-Disposition', `attachment; filename=${name}`);
        // res.set('Content-Length', buffer.length); 
        // res.send(buffer); 
        res.end(new Buffer(buffer, 'base64'));
        // return jsonFiles;
    }
    async importCsvFile(params, res) {
        console.log(params);
        const workbook = xlsx_1.default.readFile(params.file.buffer, { type: 'buffer' });
        const sheetnames = Object.keys(workbook.Sheets);
        let i = sheetnames.length;
        const resData = {};
        while (i--) {
            const sheetname = sheetnames[i];
            const arrayName = sheetname.toString();
            resData[sheetname] = xlsx_1.default.utils.sheet_to_json(workbook.Sheets[sheetname]);
        }
        return {};
    }
};
__decorate([
    core_1.Post('/'),
    core_1.DbSettings('Orm')
    // @Authentication(false)
    ,
    core_1.ReadOnly(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeorm_1.EntityManager]),
    __metadata("design:returntype", Promise)
], TranslationGroup.prototype, "save", null);
__decorate([
    core_1.Get('/modules'),
    core_1.DbSettings('Orm')
    // @Authentication(false)
    ,
    core_1.ReadOnly(true),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeorm_1.EntityManager]),
    __metadata("design:returntype", Promise)
], TranslationGroup.prototype, "listModules", null);
__decorate([
    core_1.Get('/modules/:module/entities'),
    core_1.DbSettings('Orm')
    // @Authentication(false)
    ,
    core_1.ReadOnly(true),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeorm_1.EntityManager]),
    __metadata("design:returntype", Promise)
], TranslationGroup.prototype, "listTablesDb", null);
__decorate([
    core_1.Get('/entities/:entity/fields'),
    core_1.DbSettings('Orm')
    // @Authentication(false)
    ,
    core_1.ReadOnly(true),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], TranslationGroup.prototype, "listEntityColumns", null);
__decorate([
    core_1.Get('/json'),
    core_1.DbSettings('Orm')
    // @Authentication(false)
    ,
    core_1.ReadOnly(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeorm_1.EntityManager, Object]),
    __metadata("design:returntype", Promise)
], TranslationGroup.prototype, "getJsonLanguage", null);
__decorate([
    core_1.Get('/csv'),
    core_1.DbSettings('Orm')
    // @Authentication(false)
    ,
    core_1.ReadOnly(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeorm_1.EntityManager, Object]),
    __metadata("design:returntype", Promise)
], TranslationGroup.prototype, "getCsvLanguage", null);
__decorate([
    core_1.Post('/import'),
    core_1.DbSettings('Orm'),
    core_1.Authentication(false),
    core_1.ReadOnly(false),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, Object]),
    __metadata("design:returntype", Promise)
], TranslationGroup.prototype, "importCsvFile", null);
TranslationGroup = __decorate([
    core_1.Route('/translate/groups'),
    core_1.Model('common/TranslationGroup')
], TranslationGroup);
exports.default = TranslationGroup;
