"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Kplian Ltda 2020
 *
 * MIT
 *
 * Person Controller
 *
 * @summary Account Status Controller
 * @author Favio Figueroa
 *
 * Created at     : 2020-09-17 18:55:38
 * Last modified  :
 */
const typeorm_1 = require("typeorm");
const core_1 = require("@pxp-nd/core");
const entities_1 = require("../entities");
const entities_2 = require("../entities");
const repositories_1 = require("@pxp-nd/repositories");
// @Route('/accountStatusType')
let AccountStatus = class AccountStatus extends core_1.Controller {
    async list(params) {
        // const listParam = this.getListParams(params);
        let qb = await typeorm_1.getManager()
            .createQueryBuilder(entities_1.AccountStatus, 'asm')
            .innerJoinAndSelect('asm.accountStatusType', 'ast')
            // .where('"ast".code = :code', { code: params.code })
            .where(params.code ? 'ast.code = :code' : '1=1', { code: params.code })
            .andWhere(params.tableId ? 'asm.table_id = :tableId' : '1=1', { tableId: params.tableId });
        // get initial balance
        const startDate = params.startDate; // todo change now
        const endDate = params.endDate;
        let initialBalance;
        if (startDate && endDate) {
            const qbInitialBalance = await qb.clone();
            initialBalance = await qbInitialBalance.select('count(*) as count_initial_balance, sum(asm.amount) as sum_initial_balance')
                .andWhere((params.startDate && params.endDate) ? 'asm.date < :start' : '1=1', { start: startDate })
                .getRawOne();
            qb = qb.andWhere('asm.date BETWEEN :start AND :end', { start: startDate, end: endDate });
        }
        else {
            initialBalance = {
                count_initial_balance: 0,
                sum_initial_balance: 0,
            };
        }
        //      .andWhere((params.startDate && params.endDate) ? 'asm.date BETWEEN :start AND :end' : '1=1', { start: params.startDate, end: params.endDate });
        if (params.genericFilterFields && params.genericFilterValue) {
            const genericFilterFields = params.genericFilterFields;
            const filterFieldsArray = genericFilterFields.split('#');
            qb = qb.andWhere(new typeorm_1.Brackets(sqb => {
                filterFieldsArray.forEach((field, i) => {
                    if (i === 0) {
                        sqb = sqb.where(`${field}::text ilike :value`, { value: `%${params.genericFilterValue}%` });
                    }
                    else {
                        qb = sqb.orWhere(`${field}::text ilike :value`, { value: `%${params.genericFilterValue}%` });
                    }
                });
            }));
        }
        const count = await qb.select('count(*) as count, sum(asm.amount) as total_amount').getRawOne();
        const data = await qb.offset(params.start)
            .limit(params.limit)
            // .select('asm.account_status_id, ast.code, ast.type, asm.amount, asm.description, asm.typeTransaction, TO_CHAR(asm.date, \'YYYY-MM-DD\') as date')
            .select('asm.account_status_id, ast.code, ast.type, asm.amount, asm.description, asm.typeTransaction, asm.date')
            .orderBy('asm.date', 'ASC')
            .orderBy('asm.account_status_id', 'ASC')
            .getRawMany();
        const initialBalanceAux = initialBalance.sum_initial_balance || 0;
        const totalAmount = count.total_amount || 0;
        const totalBalance = parseFloat(initialBalanceAux) + parseFloat(totalAmount);
        return { data, count: count.count, extraData: { totalAmount: count.total_amount || 0, totalBalance, totalRange: 120, initialBalance: { count_initial_balance: initialBalance.count_initial_balance || 0, sum_initial_balance: initialBalance.sum_initial_balance || 0, } } };
    }
    async add(params, manager) {
        // console.log('llega aca',params);
        const getAccountStatusTypeData = await typeorm_1.getManager()
            .createQueryBuilder(entities_2.AccountStatusType, 'astm')
            .where('astm.code = :code', { code: params.code })
            .select('astm.account_status_type_id as account_status_type_id').getRawOne();
        // console.log('getAccountStatusTypeData',getAccountStatusTypeData)
        /*
        account payable (positive)
        account receivable (positive)
        payment in advance (negative)
        payment (negative)
        adjusting account (from client)
        * */
        let amount = params.amount;
        switch (params.typeTransaction) {
            case 'account_payable':
            case 'account_receivable':
            case 'income':
            case 'interest_payment':
            case 'add_to_debt':
                if (Math.sign(amount) === -1) { // the amount is negative from client
                    // the value must be a positive
                    amount = amount * -1;
                }
                break;
            case 'payment_in_advance':
            case 'payment':
            case 'expense':
                if (Math.sign(amount) === 1) { // the amount is positive from client
                    // the value must be a negative
                    amount = amount * -1;
                }
                break;
            default: // adjusting_account
            // console.log('type transaction is not exist in the config')
        }
        console.log(amount);
        const accountStatus = new entities_1.AccountStatus();
        Object.assign(accountStatus, params);
        accountStatus.createdBy = this.user.username;
        accountStatus.accountStatusTypeId = getAccountStatusTypeData.account_status_type_id;
        accountStatus.amount = amount;
        await core_1.__(this.classValidate(accountStatus));
        await manager.save(accountStatus);
        return accountStatus;
    }
    async getBalance(params, manager) {
        return await repositories_1.accountStatusRepository().accountBalance(Number(params.tableId), String(params.code));
    }
};
__decorate([
    core_1.Get(),
    core_1.DbSettings('Orm'),
    core_1.ReadOnly(true),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], AccountStatus.prototype, "list", null);
__decorate([
    core_1.Post(),
    core_1.DbSettings('Orm'),
    core_1.ReadOnly(false),
    core_1.Log(true),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeorm_1.EntityManager]),
    __metadata("design:returntype", Promise)
], AccountStatus.prototype, "add", null);
__decorate([
    core_1.Get('/balance'),
    core_1.DbSettings('Orm'),
    core_1.ReadOnly(false),
    core_1.Log(true),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object, typeorm_1.EntityManager]),
    __metadata("design:returntype", Promise)
], AccountStatus.prototype, "getBalance", null);
AccountStatus = __decorate([
    core_1.Model('common/AccountStatus')
], AccountStatus);
exports.default = AccountStatus;
