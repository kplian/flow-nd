"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.accountStatusRepository = void 0;
const typeorm_1 = require("typeorm");
const entities_1 = require("@pxp-nd/entities");
const moment_1 = __importDefault(require("moment"));
const core_1 = require("@pxp-nd/core");
const class_validator_1 = require("class-validator");
let AccountStatusCustomRepository = class AccountStatusCustomRepository extends typeorm_1.Repository {
    async saveStatus(data, currentAccountId) {
        const statusTypeRepo = typeorm_1.getRepository(entities_1.AccountStatusType);
        let accountStatus = null;
        let type = null;
        type = await statusTypeRepo.findOne({
            where: {
                code: data.accountStatusType.code
            }
        });
        if (!type) {
            type = await statusTypeRepo.save(data.accountStatusType);
        }
        const status = await this.findOne({
            where: {
                tableId: data.accountStatus.tableId
            }
        });
        const accountStatusDb = await this.findOne({
            join: {
                alias: 'account',
                innerJoin: { type: 'account.accountStatusType' }
            },
            where: (qb) => {
                qb.where({
                    tableId: data.accountStatus.tableId,
                    accountStatusId: currentAccountId,
                }).andWhere('type.code = :code', {
                    code: data.accountStatusType.code
                });
            }
            // where: { tableId: purchaseId },
            // relations: ['accountStatusType']
        });
        const accountStatusId = currentAccountId || (accountStatusDb
            ? accountStatusDb.accountStatusId
            : null);
        if (accountStatusId) {
            data.accountStatus.description = !data.accountStatus.description ? accountStatusDb.description : data.accountStatus.description;
            accountStatus = await this.update(accountStatusId, Object.assign({}, data.accountStatus
            // date: moment().format()
            ));
            accountStatus = await this.findOne({
                where: {
                    accountStatusId: accountStatusId
                }
            });
        }
        else {
            accountStatus = await this.save(Object.assign(Object.assign({}, data.accountStatus), { accountStatusTypeId: type.accountStatusTypeId }));
        }
        return accountStatus;
    }
    async accountBalance(tableId, code) {
        const rawData = await this.query(`SELECT SUM(amount) as saldo 
                                            FROM tpar_account_status_type ast
                                                     JOIN tpar_account_status as acc
                                            ON acc.account_status_type_id = ast.account_status_type_id
                                            WHERE ast.code = '${code}'
                                              AND acc.table_id = ${tableId};`);
        return rawData[0];
    }
    async add(params, user) {
        // console.log('llega aca',params);
        const getAccountStatusTypeData = await typeorm_1.getManager()
            .createQueryBuilder(entities_1.AccountStatusType, 'astm')
            .where('astm.code = :code', { code: params.code })
            .select('astm.account_status_type_id as account_status_type_id').getRawOne();
        console.log('getAccountStatusTypeData', getAccountStatusTypeData);
        /*
        account payable (positive)
        account receivable (positive)
        payment in advance (negative)
        payment (negative)
        adjusting account (from client)
        * */
        let amount = params.amount;
        switch (params.typeTransaction) {
            case 'account_payable':
            case 'account_receivable':
                if (Math.sign(amount) === -1) { // the amount is negative from client
                    // the value must be a positive
                    amount = amount * -1;
                }
                break;
            case 'payment_in_advance':
            case 'payment':
                if (Math.sign(amount) === 1) { // the amount is positive from client
                    // the value must be a negative
                    amount = amount * -1;
                }
                break;
            default: // adjusting_account
                console.log('type transaction is not exist in the config');
        }
        console.log(amount);
        const accountStatus = new entities_1.AccountStatus();
        Object.assign(accountStatus, params);
        accountStatus.createdBy = user.username;
        accountStatus.date = moment_1.default().format('YYYY-MM-DD');
        accountStatus.accountStatusTypeId = getAccountStatusTypeData.account_status_type_id;
        accountStatus.amount = amount;
        const errors = await core_1.__(class_validator_1.validate(accountStatus));
        if (errors.length > 0) {
            throw new core_1.PxpError(406, 'Validation failed!', errors);
        }
        await this.save(accountStatus);
        return accountStatus;
    }
};
AccountStatusCustomRepository = __decorate([
    typeorm_1.EntityRepository(entities_1.AccountStatus)
], AccountStatusCustomRepository);
const accountStatusRepository = () => typeorm_1.getCustomRepository(AccountStatusCustomRepository);
exports.accountStatusRepository = accountStatusRepository;
