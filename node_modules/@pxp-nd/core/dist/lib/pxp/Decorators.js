"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StoredProcedure = exports.Model = exports.IsHtml = exports.ReadOnly = exports.DbSettings = exports.Permission = exports.Log = exports.Authentication = exports.Route = exports.Patch = exports.Delete = exports.Put = exports.Post = exports.Get = void 0;
/**
 * Kplian Ltda 2020
 *
 * MIT
 *
 * All Pxp Decorators.
 *
 * @summary Pxp decorators.
 * @author Jaime Rivera
 *
 * Created at     : 2020-06-13 18:09:48
 * Last modified  : 2020-09-17 18:29:51
 */
const RouteDefinition_1 = require("./RouteDefinition");
;
;
const setProperty = (target, propertyKey) => (value, name, overwrite = true) => {
    if (!Reflect.hasMetadata(name, target.constructor)) {
        Reflect.defineMetadata(name, {}, target.constructor);
    }
    const valueName = Reflect.getMetadata(name, target.constructor);
    if (!overwrite && !valueName[propertyKey]) {
        valueName[propertyKey] = value;
    }
    else if (overwrite) {
        valueName[propertyKey] = value;
    }
    Reflect.defineMetadata(name, valueName, target.constructor);
};
const createOptions = (options) => (target, propertyKey) => {
    options = Object.assign({
        readOnly: true,
        isHtml: false,
        dbSettings: 'Orm',
        authentication: true,
        log: true
    }, options);
    // const newProperty = setProperty(target, propertyKey);
    // // ReadOnly
    // newProperty(options.readOnly, 'readonly', false);
    // // DbSettings
    // newProperty(options.dbSettings, 'dbsettings', false);
    // // Authentication
    // newProperty(options.authentication, 'authentication', false);
    if (!Reflect.hasMetadata('optionsRoute', target.constructor)) {
        Reflect.defineMetadata('optionsRoute', {}, target.constructor);
    }
    const optionsRoute = Reflect.getMetadata('optionsRoute', target.constructor);
    optionsRoute[propertyKey] = options;
    Reflect.defineMetadata('optionsRoute', optionsRoute, target.constructor);
};
const setRoute = (path = '', method, options) => (target, propertyKey) => {
    if (!Reflect.hasMetadata('routes', target.constructor)) {
        Reflect.defineMetadata('routes', [], target.constructor);
    }
    const routes = Reflect.getMetadata('routes', target.constructor);
    routes.push({
        requestMethod: method,
        path: path === '' ? '/' + propertyKey : path,
        methodName: propertyKey
    });
    Reflect.defineMetadata('routes', routes, target.constructor);
    createOptions(options)(target, propertyKey);
};
const Get = (path, options) => setRoute(path, RouteDefinition_1.Method.get, options);
exports.Get = Get;
const Post = (path, options) => setRoute(path, RouteDefinition_1.Method.post, options);
exports.Post = Post;
const Put = (path, options) => setRoute(path, RouteDefinition_1.Method.put, options);
exports.Put = Put;
const Patch = (path, options) => setRoute(path, RouteDefinition_1.Method.patch, options);
exports.Patch = Patch;
const Delete = (path, options) => setRoute(path, RouteDefinition_1.Method.delete, options);
exports.Delete = Delete;
const Route = (controllerPath = '') => {
    return (target) => {
        Reflect.defineMetadata('controller_path', controllerPath, target);
        // Since routes are set by our methods this should almost never be true (except the controller has no methods)
        if (!Reflect.hasMetadata('routes', target)) {
            Reflect.defineMetadata('routes', [], target);
        }
    };
};
exports.Route = Route;
const Model = (model) => {
    return (target) => {
        Reflect.defineMetadata('model', model, target);
    };
};
exports.Model = Model;
const StoredProcedure = (storedProcedure) => {
    return (target) => {
        Reflect.defineMetadata('storedprocedure', storedProcedure, target);
    };
};
exports.StoredProcedure = StoredProcedure;
const Authentication = (authentication = true) => (target, propertyKey) => setProperty(target, propertyKey)(authentication, 'authentication');
exports.Authentication = Authentication;
const ReadOnly = (ronly = true) => (target, propertyKey) => setProperty(target, propertyKey)(ronly, 'readonly');
exports.ReadOnly = ReadOnly;
const IsHtml = (ishtml = false) => (target, propertyKey) => setProperty(target, propertyKey)(ishtml, 'ishtml');
exports.IsHtml = IsHtml;
const DbSettings = (modelType) => (target, propertyKey) => setProperty(target, propertyKey)(modelType, 'dbsettings');
exports.DbSettings = DbSettings;
const Permission = (permission = true) => (target, propertyKey) => setProperty(target, propertyKey)(permission, 'permission');
exports.Permission = Permission;
const Log = (log = true, config = {}) => {
    return (target, propertyKey) => {
        if (!Reflect.hasMetadata('log', target.constructor)) {
            Reflect.defineMetadata('log', {}, target.constructor);
        }
        if (!Reflect.hasMetadata('logConfig', target.constructor)) {
            Reflect.defineMetadata('logConfig', {}, target.constructor);
        }
        const logVar = Reflect.getMetadata('log', target.constructor);
        logVar[propertyKey] = log;
        const logConfig = Reflect.getMetadata('logConfig', target.constructor);
        logConfig[propertyKey] = config;
        Reflect.defineMetadata('log', logVar, target.constructor);
        Reflect.defineMetadata('logConfig', logConfig, target.constructor);
    };
};
exports.Log = Log;
