"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePdf = exports.setRobotoFont = void 0;
const path_1 = __importDefault(require("path"));
const jspdf_1 = require("jspdf");
require("jspdf-autotable");
const moment_1 = __importDefault(require("moment"));
const typeorm_1 = require("typeorm");
const Roboto_Regular_normal_js_1 = __importDefault(require("./fonts/Roboto-Regular-normal.js"));
const helper_1 = require("./helper");
const buildHeader = (doc, title) => {
    // doc.setTextColor(40);//optional
    // doc.setFontStyle('normal');//optional
    doc.setFontSize(16);
    doc.text(title.toLocaleUpperCase(), 100, 10, 'center');
    doc.line(12, 12, 200, 12); // horizontal line
};
const buildFooter = (doc, user) => {
    doc.setFontSize(12);
    doc.text('Usuario: ' + user.username, 10, 290);
    doc.text(moment_1.default().format('LLL'), 150, 290);
};
const buildParams = (doc, filters) => {
    doc.setFontSize(10);
    let init = 20;
    Object.keys(filters).forEach(key => {
        const filter = filters[key];
        doc.text(filter.label + ': ', 24, init);
        doc.text(filter.value.toString(), 50, init);
        init += 4;
    });
};
const setRobotoFont = (doc) => {
    doc.addFileToVFS('Roboto-Regular.ttf', Roboto_Regular_normal_js_1.default);
    doc.addFont('Roboto-Regular.ttf', 'Roboto', 'normal');
    doc.setFont('Roboto');
};
exports.setRobotoFont = setRobotoFont;
const totalRender = (columns = [], totals = {}) => {
    return columns.map((column) => {
        if (totals[column.dataKey]) {
            return totals[column.dataKey];
        }
        return '';
    });
};
const footStyles = {
    fillColor: '#e8e8e8',
    textColor: '#2a2a2b',
    fontSize: 11,
};
const makePdf = async (req, res) => {
    try {
        let data, params = null;
        let filters = {};
        if (!req.reportData) {
            // s-params
            params = await helper_1.parseParams(req);
            const Entity = await helper_1.getEntity(params.module, params.entity);
            data = await typeorm_1.getManager().find(Entity);
            // e-params
        }
        else {
            data = req.reportData.data;
            params = Object.assign({}, req.report);
            filters = req.reportData.filters || {};
        }
        const doc = new jspdf_1.jsPDF({ filters: ['ASCIIHexEncode'] });
        const pdfPath = path_1.default.join(__dirname, params.filename + '.pdf');
        const pageNumber = doc.internal.getNumberOfPages();
        res.setHeader('Content-Disposition', 'inline; filename="' + params.filename + '.pdf" ');
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.setHeader('Content-Type', 'application/pdf');
        // CONFIGURATION PDF
        // Optional - set properties on the document
        doc.setProperties({
            title: params.filename,
            subject: 'Generated Report',
            author: 'Kplian',
            keywords: 'generated, javascript, web 2.0',
            creator: 'MEEE'
        });
        exports.setRobotoFont(doc);
        doc.setFontSize(12);
        buildHeader(doc, params.filename);
        buildParams(doc, filters);
        doc.autoTable({
            columns: params.columns,
            margin: { top: 20 + 4 * Object.keys(filters).length },
            body: data,
            foot: [totalRender(params.columns, req.reportData.totals)],
            footStyles
        });
        /*** DETAIL REPORT START***/
        const detail = req.reportDetailData;
        if (detail) {
            doc.autoTable({
                columns: detail.columns,
                margin: { top: 20 },
                body: detail.data,
                foot: [totalRender(detail.columns, req.reportDetailData.totals)],
                footStyles
            });
        }
        /*** DETAIL REPORT END ***/
        doc.setPage(pageNumber);
        buildFooter(doc, req.user);
        res.end(doc.output());
        // doc.save(pdfPath + '.pdf');
    }
    catch (err) {
        console.log(err);
        res.status(400).json({ message: 'An error occured in process' });
    }
};
exports.makePdf = makePdf;
