"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Controller = void 0;
/**
 * Kplian Ltda 2020
 *
 * MIT
 *
 * Controller Class.
 *
 * @summary All common controllers functionality go here (all controllers should inherit this class).
 * @author Jaime Rivera
 *
 * Created at     : 2020-06-13 18:09:48
 * Last modified  : 2020-10-13 15:36:31
 * Last modified  : 2021-03-10 15:36:31 - Favio Figueroa
 * Last modified  : 2021-05-01 18:35:31 - Favio Figueroa
 */
const typeorm_1 = require("typeorm");
const class_validator_1 = require("class-validator");
const lodash_1 = __importDefault(require("lodash"));
const express_1 = require("express");
const joi_1 = __importDefault(require("joi"));
const index_1 = require("./index");
// import { User } from '@pxp-nd/entities';
// import { isAuthenticated } from '@pxp-nd/auth';
const ParseParams_1 = require("./middlewares/ParseParams");
const isReportMiddleware_1 = require("./middlewares/isReportMiddleware");
const pdf_1 = require("../reports/pdf");
const xlsx_1 = require("../reports/xlsx");
// import * as entities from '@pxp-nd/entities';
// const pxpEntities: any = entities;
class Controller {
    constructor(module, Entity = null, config = {
        apiPrefix: '/api',
        defaultDbSettings: 'Orm',
        middlewares: [],
        entities: {},
    }) {
        this.router = express_1.Router();
        this.path = '';
        this.module = '';
        this.modelString = '';
        this.transactionCode = '';
        this.user = {}; //User;
        this.basicRoutes = [
            { requestMethod: 'post', path: '/add', methodName: 'add' },
            { requestMethod: 'delete', path: '/delete/:id', methodName: 'delete' },
            { requestMethod: 'patch', path: '/edit/:id', methodName: 'edit' },
            { requestMethod: 'get', path: '/list', methodName: 'list' }
        ];
        this.basicReadOnly = {
            add: false,
            edit: false,
            list: true,
            delete: false
        };
        this.validated = false;
        this.module = module;
        this.config = config;
        if (Reflect.hasMetadata('model', this.constructor)) {
            this.modelString = Reflect.getMetadata('model', this.constructor);
            const [moduleName, entityName] = this.modelString.split('/');
            const mainDir = process.cwd();
            try {
                if (Entity) {
                    this.model = Entity;
                }
                else if (config.modules && config.modules[this.module]) {
                    const moduleExternal = config.modules[this.module];
                    this.model = moduleExternal.entities[entityName];
                }
                else {
                    Promise.resolve().then(() => __importStar(require(`${mainDir}/dist/modules/${moduleName}/entity/${entityName}`))).then((model) => {
                        this.model = model.default;
                    });
                }
            }
            catch (_a) {
                throw new index_1.PxpError(500, 'Model defined in  ' + this.constructor.name + ' not found.');
            }
        }
        this.initializeRoutes();
    }
    initializeRoutes() {
        let routes = Reflect.getMetadata('routes', this.constructor);
        this.path = '/' + this.constructor.name;
        // get controller path
        if (Reflect.hasMetadata('controller_path', this.constructor)) {
            this.path = Reflect.getMetadata('controller_path', this.constructor);
        }
        // get read only
        let readonly = Reflect.getMetadata('readonly', this.constructor) || {};
        // get authentication
        const authentication = Reflect.getMetadata('authentication', this.constructor) || {};
        // get permission
        const permission = Reflect.getMetadata('permission', this.constructor) || {};
        // get log
        const log = Reflect.getMetadata('log', this.constructor) || {};
        // get dbsettings
        const dbsettings = Reflect.getMetadata('dbsettings', this.constructor) || {};
        // get logConfig
        const logConfig = Reflect.getMetadata('logConfig', this.constructor) || {};
        // define basic routes
        if (this.modelString !== '') {
            routes = lodash_1.default.union(this.basicRoutes, routes);
            readonly = Object.assign(Object.assign({}, this.basicReadOnly), readonly);
        }
        routes.forEach((route) => {
            const methodDbSettings = dbsettings[route.methodName] || this.config.defaultDbSettings;
            if (!(route.methodName in readonly)) {
                throw new index_1.PxpError(500, 'ReadOnly decorator was not defined for ' +
                    route.methodName +
                    ' in ' +
                    this.constructor.name +
                    ' controller.');
            }
            if (route.methodName in authentication &&
                authentication[route.methodName] === false) {
                this.router[route.requestMethod](this.config.apiPrefix + '/' + this.module + this.path + route.path, 
                // MIDDLEWARES AREA
                [
                    ParseParams_1.parseParams
                ], async (req, res, next) => {
                    // Execute our method for this path and pass our express request and response object.
                    // const params = { ...req.query, ...req.body, ...req.params };
                    const params = Object.assign(Object.assign({}, req.files), req.paramasMerge);
                    this.pxpParams = req.pxpParams;
                    this.transactionCode = (this.module + this.path + route.path)
                        .split('/')
                        .join('.')
                        .toLowerCase();
                    this.validated = false;
                    try {
                        await index_1.__(this.genericMethodWrapper(params, req, next, res, route.methodName, methodDbSettings, readonly[route.methodName], false, log[route.methodName], logConfig[route.methodName]));
                    }
                    catch (ex) {
                        const now = new Date();
                        const iniAt = req.start;
                        const endsAt = now.valueOf() - iniAt.valueOf();
                        res.logId = await index_1.__(index_1.insertLog('nouser', 'mac', req.ip, 'error', ex.tecMessage, this.module, this.transactionCode, '', // query
                        params, ex.stack, ex.statusCode, endsAt, logConfig));
                        index_1.errorMiddleware(ex, req, res);
                    }
                });
            }
            else {
                this.router[route.requestMethod](this.config.apiPrefix + '/' + this.module + this.path + route.path, 
                // MIDDLEWARES AREA
                [
                    ...this.config.middlewares,
                    isReportMiddleware_1.isReportMiddleware,
                    ParseParams_1.parseParams
                ], async (req, res, next) => {
                    // Execute our method for this path and pass our express request and response object.
                    const params = Object.assign(Object.assign({}, req.files), req.paramasMerge);
                    this.pxpParams = req.pxpParams;
                    if (req.user) {
                        // this.user = req.user as User;
                        this.user = req.user;
                    }
                    this.transactionCode = (this.module + this.path + route.path)
                        .split('/')
                        .join('.')
                        .toLowerCase();
                    this.validated = false;
                    try {
                        await index_1.__(this.genericMethodWrapper(params, req, next, res, route.methodName, methodDbSettings, readonly[route.methodName], permission[route.methodName], log[route.methodName], logConfig[route.methodName]));
                    }
                    catch (ex) {
                        const now = new Date();
                        const iniAt = req.start;
                        const endsAt = now.valueOf() - iniAt.valueOf();
                        res.logId = (await index_1.__(index_1.insertLog(this.user && this.user.username ? this.user.username : 'nouser', 'mac', req.ip, 'error', ex.tecMessage, this.module, this.transactionCode, '', // query
                        params, ex.stack, ex.statusCode, endsAt, logConfig)));
                        index_1.errorMiddleware(ex, req, res);
                    }
                });
            }
        });
    }
    async genericMethodWrapper(params, req, next, res, methodName, dbsettings, readonly, permission = true, log = true, logConfig = {}) {
        if (dbsettings === 'Orm') {
            await index_1.__(this.ormMethodWrapper(params, req, next, res, methodName, readonly, permission, log, logConfig));
        }
        else if (dbsettings === 'Procedure') {
            await index_1.__(this.procedureMethodWrapper(params, next, res, methodName, readonly, permission, log, logConfig));
        }
        else {
            await this.sqlMethodWrapper(params, next, res, methodName, readonly, permission, log, logConfig);
        }
    }
    async ormMethodWrapper(params, req, next, res, methodName, readonly, permission = true, log = true, logConfig = {}) {
        let metResponse;
        if (permission) {
            if (this.user && this.user.roles && this.user.roles.length === 0) {
                const hasPermission = await index_1.__(index_1.userHasPermission(this.config.entities.Role)(this.user.userId, this.transactionCode));
                if (!hasPermission) {
                    throw new index_1.PxpError(403, 'Access denied to execute this method');
                }
            }
        }
        if (readonly) {
            metResponse = await index_1.__(eval(`this.${methodName}(params, res)`));
        }
        else {
            const connection = typeorm_1.getConnection(process.env.DB_WRITE_CONNECTION_NAME);
            const queryRunner = connection.createQueryRunner();
            // establish real database connection using our new query runner
            await index_1.__(queryRunner.connect());
            await index_1.__(queryRunner.startTransaction());
            try {
                metResponse = (await eval(`this.${methodName}(params, queryRunner.manager, res)`));
                await queryRunner.commitTransaction();
            }
            catch (err) {
                await queryRunner.rollbackTransaction();
                throw err;
            }
            finally {
                await index_1.__(queryRunner.release());
            }
        }
        if (log) {
            const now = new Date();
            const iniAt = req.start;
            const endsAt = now.valueOf() - iniAt.valueOf();
            index_1.__(index_1.insertLog(this.user && this.user.username ? this.user.username : 'nouser', 'mac', req.ip, 'success', 'successful transaction', this.module, this.transactionCode, '', params, JSON.stringify(metResponse), '200', endsAt, logConfig));
        }
        if (req.report && req.report.type === 'pdf') {
            req.reportData = metResponse;
            pdf_1.makePdf(req, res);
        }
        else if (req.report && req.report.type === 'xlsx') {
            req.reportData = metResponse;
            xlsx_1.makeXlsx(req, res);
        }
        else {
            res.json(metResponse);
        }
    }
    async list(params) {
        const connection = typeorm_1.getConnection(process.env.DB_WRITE_CONNECTION_NAME);
        const queryRunner = connection.getMetadata(this.model).ownColumns.find(column => column.isPrimary === true);
        // ffp search if in the params has been sent the primary key
        const primaryKeyColumn = queryRunner.propertyName;
        if (primaryKeyColumn in params) {
            const findOne = await index_1.__(this.model.findOne({ where: { [primaryKeyColumn]: params[primaryKeyColumn] } }));
            return { data: findOne, count: 1 };
        }
        // filter by some column that exist in the entity
        // ffp if some column is into of params for added in the condition
        let ownColumnsForSchema = {};
        const whereOwnColumns = connection.getMetadata(this.model).ownColumns.reduce((t, column) => {
            if (`_${column.propertyName}` in params) {
                ownColumnsForSchema = Object.assign(Object.assign({}, ownColumnsForSchema), { [`_${column.propertyName}`]: joi_1.default.string() });
                t = Object.assign(Object.assign({}, t), { [column.propertyName]: params[`_${column.propertyName}`] });
            }
            return t;
        }, {});
        const schema = this.getListSchema(ownColumnsForSchema);
        const resParams = await index_1.__(this.schemaValidate(schema, params));
        const listParam = this.getListParams(resParams, whereOwnColumns);
        const [rows, count] = await index_1.__(this.model.findAndCount(listParam));
        return { data: rows, count };
    }
    async add(params, manager) {
        const modelInstance = new this.model();
        Object.assign(modelInstance, params);
        modelInstance.createdBy = this.user ? this.user.username : '_';
        await index_1.__(this.classValidate(modelInstance));
        await manager.save(modelInstance);
        return modelInstance;
    }
    async edit(params, manager) {
        const modelInstance = (await index_1.__(this.model.findOne(params.id)));
        if (!modelInstance) {
            throw new index_1.PxpError(406, 'Record not found');
        }
        const editParams = params;
        Object.assign(modelInstance, editParams);
        delete editParams.id;
        modelInstance.modifiedBy = this.user ? this.user.username : null;
        await index_1.__(this.classValidate(modelInstance));
        await manager.save(modelInstance);
        return modelInstance;
    }
    async delete(params, manager) {
        const modelInstance = (await index_1.__(this.model.findOne(params.id)));
        if (!modelInstance) {
            throw new index_1.PxpError(406, 'Record not found');
        }
        await manager.remove(modelInstance);
        return modelInstance;
    }
    getListParams(params, where) {
        const whereGenericFilter = [];
        if (params.genericFilterFields) {
            const genericFilterFields = params.genericFilterFields;
            const filterFieldsArray = genericFilterFields.split('#');
            filterFieldsArray.forEach((field) => {
                whereGenericFilter.push(Object.assign({ [field]: typeorm_1.Like('%' + params.genericFilterValue + '%') }, where));
            });
        }
        const res = {
            where: whereGenericFilter.length > 0 ? whereGenericFilter : [where],
            skip: params.start,
            take: params.limit,
            order: {
                [params.sort]: String(params.dir).toUpperCase()
            }
        };
        // ffp search if in this request is sending the id
        return res;
    }
    async procedureMethodWrapper(params, next, res, methodName, readonly, permission = true, log = true, logConfig = {}) {
        console.log('before function');
        await eval(`this.${methodName}(req, res)`);
        console.log('after function');
    }
    async sqlMethodWrapper(params, next, res, methodName, readonly, permission = true, log = true, logConfig = {}) {
        console.log('before function');
        await eval(`this.${methodName}(req, res)`);
        console.log('after function');
    }
    async classValidate(model) {
        const errors = await index_1.__(class_validator_1.validate(model));
        this.validated = true;
        if (errors.length > 0) {
            throw new index_1.PxpError(406, 'Validation failed!', errors);
        }
    }
    async schemaValidate(schema, params) {
        const value = await index_1.__(schema.validateAsync(params, { abortEarly: false }), true);
        this.validated = true;
        return value;
    }
    getListSchema(ownColumns) {
        const schema = joi_1.default.object(Object.assign({ start: joi_1.default.number().integer().required(), limit: joi_1.default.number().integer().positive().required(), sort: joi_1.default.string().min(2).required(), dir: joi_1.default.string().min(3).max(4).required(), genericFilterFields: joi_1.default.string().min(2), genericFilterValue: joi_1.default.string().min(1) }, ownColumns));
        return schema;
    }
}
exports.Controller = Controller;
